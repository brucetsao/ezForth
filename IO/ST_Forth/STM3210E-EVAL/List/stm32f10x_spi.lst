###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.20.0.50892/W32 for ARM     07/Oct/2009  13:04:00 #
# Copyright 1999-2008 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f #
#                    10x_spi.c                                                #
#    Command line =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f #
#                    10x_spi.c -D VECT_TAB_FLASH -lC                          #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\List #
#                    \ -o F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL #
#                    \Obj\ --debug --endian=little --cpu=Cortex-M3 -e         #
#                    --char_is_signed --require_prototypes --fpu=None         #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 5.0\ARM\INC\DLib_Config_Full.h" -I             #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\ -I                #
#                    F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\inc\ -I    #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.0\ARM\INC\" -Ohz                                       #
#    List file    =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\List #
#                    \stm32f10x_spi.lst                                       #
#    Object file  =  F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\STM3210E-EVAL\Obj\ #
#                    stm32f10x_spi.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

F:\CoLtd\Forth\MCU\STM32F10x\ST_Forth\library\src\stm32f10x_spi.c
      1          /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
      2          * File Name          : stm32f10x_spi.c
      3          * Author             : MCD Application Team
      4          * Version            : V2.0.3
      5          * Date               : 09/22/2008
      6          * Description        : This file provides all the SPI firmware functions.
      7          ********************************************************************************
      8          * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
      9          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     10          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     11          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     12          * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     13          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     14          *******************************************************************************/
     15          
     16          /* Includes ------------------------------------------------------------------*/
     17          #include "stm32f10x_spi.h"
     18          #include "stm32f10x_rcc.h"
     19          
     20          /* Private typedef -----------------------------------------------------------*/
     21          /* Private define ------------------------------------------------------------*/
     22          /* SPI SPE mask */
     23          #define CR1_SPE_Set          ((u16)0x0040)
     24          #define CR1_SPE_Reset        ((u16)0xFFBF)
     25          
     26          /* I2S I2SE mask */
     27          #define I2SCFGR_I2SE_Set     ((u16)0x0400)
     28          #define I2SCFGR_I2SE_Reset   ((u16)0xFBFF)
     29          
     30          /* SPI CRCNext mask */
     31          #define CR1_CRCNext_Set      ((u16)0x1000)
     32          
     33          /* SPI CRCEN mask */
     34          #define CR1_CRCEN_Set        ((u16)0x2000)
     35          #define CR1_CRCEN_Reset      ((u16)0xDFFF)
     36          
     37          /* SPI SSOE mask */
     38          #define CR2_SSOE_Set         ((u16)0x0004)
     39          #define CR2_SSOE_Reset       ((u16)0xFFFB)
     40          
     41          /* SPI registers Masks */
     42          #define CR1_CLEAR_Mask       ((u16)0x3040)
     43          #define I2SCFGR_CLEAR_Mask   ((u16)0xF040)
     44          
     45          /* SPI or I2S mode selection masks */
     46          #define SPI_Mode_Select      ((u16)0xF7FF)
     47          #define I2S_Mode_Select      ((u16)0x0800) 
     48          
     49          /* Private macro -------------------------------------------------------------*/
     50          /* Private variables ---------------------------------------------------------*/
     51          /* Private function prototypes -----------------------------------------------*/
     52          /* Private functions ---------------------------------------------------------*/
     53          
     54          /*******************************************************************************
     55          * Function Name  : SPI_I2S_DeInit
     56          * Description    : Deinitializes the SPIx peripheral registers to their default
     57          *                  reset values (Affects also the I2Ss).
     58          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
     59          * Output         : None
     60          * Return         : None
     61          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
     62          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
     63          {
   \                     SPI_I2S_DeInit:
   \   00000000   80B5               PUSH     {R7,LR}
     64            /* Check the parameters */
     65            assert_param(IS_SPI_ALL_PERIPH(SPIx));
     66            
     67            switch (*(u32*)&SPIx)
   \   00000002   1549               LDR.N    R1,??SPI_I2S_DeInit_0  ;; 0x40003800
   \   00000004   401A               SUBS     R0,R0,R1
   \   00000006   12D0               BEQ.N    ??SPI_I2S_DeInit_1
   \   00000008   4FF48061           MOV      R1,#+1024
   \   0000000C   401A               SUBS     R0,R0,R1
   \   0000000E   17D0               BEQ.N    ??SPI_I2S_DeInit_2
   \   00000010   4FF47441           MOV      R1,#+62464
   \   00000014   401A               SUBS     R0,R0,R1
   \   00000016   1DD1               BNE.N    ??SPI_I2S_DeInit_3
     68            {
     69              case SPI1_BASE:
     70                /* Enable SPI1 reset state */
     71                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   00000018   0121               MOVS     R1,#+1
   \   0000001A   4FF48050           MOV      R0,#+4096
   \   0000001E   ........           BL       RCC_APB2PeriphResetCmd
     72                /* Release SPI1 from reset state */
     73                RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   4FF48050           MOV      R0,#+4096
   \   00000028   ........           BL       RCC_APB2PeriphResetCmd
   \   0000002C   01BD               POP      {R0,PC}
     74                break;
     75          
     76              case SPI2_BASE:
     77                /* Enable SPI2 reset state */
     78                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \                     ??SPI_I2S_DeInit_1:
   \   0000002E   0121               MOVS     R1,#+1
   \   00000030   4FF48040           MOV      R0,#+16384
   \   00000034   ........           BL       RCC_APB1PeriphResetCmd
     79                /* Release SPI2 from reset state */
     80                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000038   0021               MOVS     R1,#+0
   \   0000003A   4FF48040           MOV      R0,#+16384
   \   0000003E   07E0               B.N      ??SPI_I2S_DeInit_4
     81                break;
     82          
     83              case SPI3_BASE:
     84                /* Enable SPI3 reset state */
     85                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \                     ??SPI_I2S_DeInit_2:
   \   00000040   0121               MOVS     R1,#+1
   \   00000042   4FF40040           MOV      R0,#+32768
   \   00000046   ........           BL       RCC_APB1PeriphResetCmd
     86                /* Release SPI3 from reset state */
     87                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   4FF40040           MOV      R0,#+32768
   \                     ??SPI_I2S_DeInit_4:
   \   00000050   ........           BL       RCC_APB1PeriphResetCmd
     88                break;
     89          
     90              default:
     91                break;
     92            }
     93          }
   \                     ??SPI_I2S_DeInit_3:
   \   00000054   01BD               POP      {R0,PC}          ;; return
   \   00000056   00BF               Nop      
   \                     ??SPI_I2S_DeInit_0:
   \   00000058   00380040           DC32     0x40003800
     94          
     95          /*******************************************************************************
     96          * Function Name  : SPI_Init
     97          * Description    : Initializes the SPIx peripheral according to the specified 
     98          *                  parameters in the SPI_InitStruct.
     99          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    100          *                  - SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    101          *                    contains the configuration information for the specified
    102          *                    SPI peripheral.
    103          * Output         : None
    104          * Return         : None
    105          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    106          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    107          {
    108            u16 tmpreg = 0;
    109            
    110            /* check the parameters */
    111            assert_param(IS_SPI_ALL_PERIPH(SPIx));   
    112            
    113            /* Check the SPI parameters */
    114            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    115            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    116            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    117            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    118            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    119            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    120            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    121            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    122            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    123          
    124          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    125            /* Get the SPIx CR1 value */
    126            tmpreg = SPIx->CR1;
   \                     SPI_Init:
   \   00000000   0288               LDRH     R2,[R0, #+0]
    127            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    128            tmpreg &= CR1_CLEAR_Mask;
    129            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    130               master/salve mode, CPOL and CPHA */
    131            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    132            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    133            /* Set LSBFirst bit according to SPI_FirstBit value */
    134            /* Set BR bits according to SPI_BaudRatePrescaler value */
    135            /* Set CPOL bit according to SPI_CPOL value */
    136            /* Set CPHA bit according to SPI_CPHA value */
    137            tmpreg |= (u16)((u32)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    138                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    139                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    140                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
    141            /* Write to SPIx CR1 */
    142            SPIx->CR1 = tmpreg;
   \   00000002   02F44152           AND      R2,R2,#0x3040
   \   00000006   0B88               LDRH     R3,[R1, #+0]
   \   00000008   1A43               ORRS     R2,R3,R2
   \   0000000A   4B88               LDRH     R3,[R1, #+2]
   \   0000000C   1A43               ORRS     R2,R3,R2
   \   0000000E   8B88               LDRH     R3,[R1, #+4]
   \   00000010   1A43               ORRS     R2,R3,R2
   \   00000012   CB88               LDRH     R3,[R1, #+6]
   \   00000014   1A43               ORRS     R2,R3,R2
   \   00000016   0B89               LDRH     R3,[R1, #+8]
   \   00000018   1A43               ORRS     R2,R3,R2
   \   0000001A   4B89               LDRH     R3,[R1, #+10]
   \   0000001C   1A43               ORRS     R2,R3,R2
   \   0000001E   8B89               LDRH     R3,[R1, #+12]
   \   00000020   1A43               ORRS     R2,R3,R2
   \   00000022   CB89               LDRH     R3,[R1, #+14]
   \   00000024   1A43               ORRS     R2,R3,R2
   \   00000026   0280               STRH     R2,[R0, #+0]
    143            
    144            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    145            SPIx->I2SCFGR &= SPI_Mode_Select;		
   \   00000028   828B               LDRH     R2,[R0, #+28]
   \   0000002A   4FF2FF73           MOVW     R3,#+63487
   \   0000002E   1A40               ANDS     R2,R3,R2
   \   00000030   8283               STRH     R2,[R0, #+28]
    146          
    147          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    148            /* Write to SPIx CRCPOLY */
    149            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000032   098A               LDRH     R1,[R1, #+16]
   \   00000034   0182               STRH     R1,[R0, #+16]
    150          }
   \   00000036   7047               BX       LR               ;; return
    151          
    152          /*******************************************************************************
    153          * Function Name  : I2S_Init
    154          * Description    : Initializes the SPIx peripheral according to the specified 
    155          *                  parameters in the I2S_InitStruct.
    156          * Input          : - SPIx: where x can be  2 or 3 to select the SPI peripheral
    157          *                     (configured in I2S mode).
    158          *                  - I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    159          *                    contains the configuration information for the specified
    160          *                    SPI peripheral configured in I2S mode.
    161          * Output         : None
    162          * Return         : None
    163          ******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    164          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    165          {
   \                     I2S_Init:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   \   00000004   0500               MOVS     R5,R0
   \   00000006   0C00               MOVS     R4,R1
    166            u16 tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
    167            u32 tmp = 0;
    168            RCC_ClocksTypeDef RCC_Clocks;
    169             
    170            /* Check the I2S parameters */
    171            assert_param(IS_SPI_23_PERIPH(SPIx));
    172            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    173            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    174            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    175            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    176            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    177            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    178          
    179          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    180          
    181            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    182            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
   \   00000008   A88B               LDRH     R0,[R5, #+28]
   \   0000000A   4FF24001           MOVW     R1,#+61504
   \   0000000E   0840               ANDS     R0,R1,R0
   \   00000010   A883               STRH     R0,[R5, #+28]
    183            SPIx->I2SPR = 0x0002;
   \   00000012   0220               MOVS     R0,#+2
   \   00000014   2884               STRH     R0,[R5, #+32]
    184            
    185            /* Get the I2SCFGR register value */
    186            tmpreg = SPIx->I2SCFGR;
   \   00000016   AE8B               LDRH     R6,[R5, #+28]
    187            
    188            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    189            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   00000018   2089               LDRH     R0,[R4, #+8]
   \   0000001A   0228               CMP      R0,#+2
   \   0000001C   02D1               BNE.N    ??I2S_Init_0
    190            {
    191              i2sodd = (u16)0;
   \   0000001E   0020               MOVS     R0,#+0
    192              i2sdiv = (u16)2;   
   \   00000020   0221               MOVS     R1,#+2
   \   00000022   2AE0               B.N      ??I2S_Init_1
    193            }
    194            /* If the requested audio frequency is not the default, compute the prescaler */
    195            else
    196            {
    197              /* Check the frame length (For the Prescaler computing) */
    198              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \                     ??I2S_Init_0:
   \   00000024   A088               LDRH     R0,[R4, #+4]
   \   00000026   08B9               CBNZ     R0,??I2S_Init_2
    199              {
    200                /* Packet length is 16 bits */
    201                packetlength = 1;
   \   00000028   0127               MOVS     R7,#+1
   \   0000002A   00E0               B.N      ??I2S_Init_3
    202              }
    203              else
    204              {
    205                /* Packet length is 32 bits */
    206                packetlength = 2;
   \                     ??I2S_Init_2:
   \   0000002C   0227               MOVS     R7,#+2
    207              }
    208              /* Get System Clock frequency */
    209              RCC_GetClocksFreq(&RCC_Clocks);
   \                     ??I2S_Init_3:
   \   0000002E   00A8               ADD      R0,SP,#+0
   \   00000030   ........           BL       RCC_GetClocksFreq
    210              
    211              /* Compute the Real divider depending on the MCLK output state with a flaoting point */
    212              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   00000034   2189               LDRH     R1,[R4, #+8]
   \   00000036   0A20               MOVS     R0,#+10
   \   00000038   009A               LDR      R2,[SP, #+0]
   \   0000003A   4243               MULS     R2,R2,R0
   \   0000003C   E388               LDRH     R3,[R4, #+6]
   \   0000003E   4FF4007C           MOV      R12,#+512
   \   00000042   6345               CMP      R3,R12
   \   00000044   03D1               BNE.N    ??I2S_Init_4
    213              {
    214                /* MCLK output is enabled */
    215                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (256 * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   00000046   0902               LSLS     R1,R1,#+8
   \   00000048   B2FBF1F1           UDIV     R1,R2,R1
   \   0000004C   03E0               B.N      ??I2S_Init_5
    216              }
    217              else
    218              {
    219                /* MCLK output is disabled */
    220                tmp = (u16)(((10 * RCC_Clocks.SYSCLK_Frequency) / (32 * packetlength * I2S_InitStruct->I2S_AudioFreq)) + 5);
   \                     ??I2S_Init_4:
   \   0000004E   7943               MULS     R1,R7,R1
   \   00000050   4901               LSLS     R1,R1,#+5
   \   00000052   B2FBF1F1           UDIV     R1,R2,R1
   \                     ??I2S_Init_5:
   \   00000056   491D               ADDS     R1,R1,#+5
   \   00000058   89B2               UXTH     R1,R1
    221              }
    222              
    223              /* Remove the flaoting point */
    224              tmp = tmp/10;  
   \   0000005A   B1FBF0F0           UDIV     R0,R1,R0
    225                
    226              /* Check the parity of the divider */
    227              i2sodd = (u16)(tmp & (u16)0x0001);
   \   0000005E   00F00102           AND      R2,R0,#0x1
    228             
    229              /* Compute the i2sdiv prescaler */
    230              i2sdiv = (u16)((tmp - i2sodd) / 2);
   \   00000062   801A               SUBS     R0,R0,R2
   \   00000064   4108               LSRS     R1,R0,#+1
    231             
    232              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    233              i2sodd = (u16) (i2sodd << 8);
   \   00000066   1002               LSLS     R0,R2,#+8
    234            }
    235            
    236            /* Test if the divider is 1 or 0 */
    237            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \   00000068   89B2               UXTH     R1,R1
   \   0000006A   0229               CMP      R1,#+2
   \   0000006C   03D3               BCC.N    ??I2S_Init_6
   \   0000006E   4FF48072           MOV      R2,#+256
   \   00000072   9142               CMP      R1,R2
   \   00000074   01D3               BCC.N    ??I2S_Init_1
    238            {
    239              /* Set the default values */
    240              i2sdiv = 2;
   \                     ??I2S_Init_6:
   \   00000076   0221               MOVS     R1,#+2
    241              i2sodd = 0;
   \   00000078   0020               MOVS     R0,#+0
    242            }
    243          
    244            /* Write to SPIx I2SPR register the computed value */
    245            SPIx->I2SPR = (u16)(i2sdiv | i2sodd | I2S_InitStruct->I2S_MCLKOutput);  
   \                     ??I2S_Init_1:
   \   0000007A   0843               ORRS     R0,R0,R1
   \   0000007C   E188               LDRH     R1,[R4, #+6]
   \   0000007E   0843               ORRS     R0,R1,R0
   \   00000080   2884               STRH     R0,[R5, #+32]
    246           
    247            /* Configure the I2S with the SPI_InitStruct values */
    248            tmpreg |= (u16)(I2S_Mode_Select | I2S_InitStruct->I2S_Mode | \
    249                            I2S_InitStruct->I2S_Standard | I2S_InitStruct->I2S_DataFormat | \
    250                            I2S_InitStruct->I2S_CPOL);
    251           
    252            /* Write to SPIx I2SCFGR */  
    253            SPIx->I2SCFGR = tmpreg;                                    
   \   00000082   2088               LDRH     R0,[R4, #+0]
   \   00000084   3043               ORRS     R0,R0,R6
   \   00000086   6188               LDRH     R1,[R4, #+2]
   \   00000088   0843               ORRS     R0,R1,R0
   \   0000008A   A188               LDRH     R1,[R4, #+4]
   \   0000008C   0843               ORRS     R0,R1,R0
   \   0000008E   6189               LDRH     R1,[R4, #+10]
   \   00000090   0843               ORRS     R0,R1,R0
   \   00000092   40F40060           ORR      R0,R0,#0x800
   \   00000096   A883               STRH     R0,[R5, #+28]
    254          }
   \   00000098   05B0               ADD      SP,SP,#+20
   \   0000009A   F0BD               POP      {R4-R7,PC}       ;; return
    255          
    256          /*******************************************************************************
    257          * Function Name  : SPI_StructInit
    258          * Description    : Fills each SPI_InitStruct member with its default value.
    259          * Input          : - SPI_InitStruct : pointer to a SPI_InitTypeDef structure
    260          *                    which will be initialized.
    261          * Output         : None
    262          * Return         : None
    263          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    264          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    265          {
    266          /*--------------- Reset SPI init structure parameters values -----------------*/
    267            /* Initialize the SPI_Direction member */
    268            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    269          
    270            /* initialize the SPI_Mode member */
    271            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   4180               STRH     R1,[R0, #+2]
    272          
    273            /* initialize the SPI_DataSize member */
    274            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000006   8180               STRH     R1,[R0, #+4]
    275          
    276            /* Initialize the SPI_CPOL member */
    277            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   00000008   C180               STRH     R1,[R0, #+6]
    278          
    279            /* Initialize the SPI_CPHA member */
    280            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   0000000A   0181               STRH     R1,[R0, #+8]
    281          
    282            /* Initialize the SPI_NSS member */
    283            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   0000000C   4181               STRH     R1,[R0, #+10]
    284          
    285            /* Initialize the SPI_BaudRatePrescaler member */
    286            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   0000000E   8181               STRH     R1,[R0, #+12]
    287          
    288            /* Initialize the SPI_FirstBit member */
    289            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000010   C181               STRH     R1,[R0, #+14]
    290          
    291            /* Initialize the SPI_CRCPolynomial member */
    292            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000012   0721               MOVS     R1,#+7
   \   00000014   0182               STRH     R1,[R0, #+16]
    293          }
   \   00000016   7047               BX       LR               ;; return
    294          
    295          /*******************************************************************************
    296          * Function Name  : I2S_StructInit
    297          * Description    : Fills each I2S_InitStruct member with its default value.
    298          * Input          : - I2S_InitStruct : pointer to a I2S_InitTypeDef structure
    299          *                    which will be initialized.
    300          * Output         : None
    301          * Return         : None
    302          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    303          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    304          {
    305          /*--------------- Reset I2S init structure parameters values -----------------*/
    306            /* Initialize the I2S_Mode member */
    307            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit:
   \   00000000   0021               MOVS     R1,#+0
   \   00000002   0180               STRH     R1,[R0, #+0]
    308            
    309            /* Initialize the I2S_Standard member */
    310            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   4180               STRH     R1,[R0, #+2]
    311            
    312            /* Initialize the I2S_DataFormat member */
    313            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000006   8180               STRH     R1,[R0, #+4]
    314            
    315            /* Initialize the I2S_MCLKOutput member */
    316            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   00000008   C180               STRH     R1,[R0, #+6]
    317            
    318            /* Initialize the I2S_AudioFreq member */
    319            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   0000000A   0221               MOVS     R1,#+2
   \   0000000C   0181               STRH     R1,[R0, #+8]
    320            
    321            /* Initialize the I2S_CPOL member */
    322            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   0000000E   0021               MOVS     R1,#+0
   \   00000010   4181               STRH     R1,[R0, #+10]
    323          }
   \   00000012   7047               BX       LR               ;; return
    324          
    325          /*******************************************************************************
    326          * Function Name  : SPI_Cmd
    327          * Description    : Enables or disables the specified SPI peripheral.
    328          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    329          *                  - NewState: new state of the SPIx peripheral. 
    330          *                    This parameter can be: ENABLE or DISABLE.
    331          * Output         : None
    332          * Return         : None
    333          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    334          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    335          {
    336            /* Check the parameters */
    337            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    338            assert_param(IS_FUNCTIONAL_STATE(NewState));
    339          
    340            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   00000000   0029               CMP      R1,#+0
   \   00000002   0188               LDRH     R1,[R0, #+0]
   \   00000004   02D0               BEQ.N    ??SPI_Cmd_0
    341            {
    342              /* Enable the selected SPI peripheral */
    343              SPIx->CR1 |= CR1_SPE_Set;
   \   00000006   41F04001           ORR      R1,R1,#0x40
   \   0000000A   02E0               B.N      ??SPI_Cmd_1
    344            }
    345            else
    346            {
    347              /* Disable the selected SPI peripheral */
    348              SPIx->CR1 &= CR1_SPE_Reset;
   \                     ??SPI_Cmd_0:
   \   0000000C   4FF6BF72           MOVW     R2,#+65471
   \   00000010   1140               ANDS     R1,R2,R1
   \                     ??SPI_Cmd_1:
   \   00000012   0180               STRH     R1,[R0, #+0]
    349            }
    350          }
   \   00000014   7047               BX       LR               ;; return
    351          
    352          /*******************************************************************************
    353          * Function Name  : I2S_Cmd
    354          * Description    : Enables or disables the specified SPI peripheral (in I2S mode).
    355          * Input          : - SPIx: where x can be 2 or 3 to select the SPI peripheral.
    356          *                  - NewState: new state of the SPIx peripheral. 
    357          *                    This parameter can be: ENABLE or DISABLE.
    358          * Output         : None
    359          * Return         : None
    360          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    361          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_SPI_23_PERIPH(SPIx));
    365            assert_param(IS_FUNCTIONAL_STATE(NewState));
    366          
    367            if (NewState != DISABLE)
   \                     I2S_Cmd:
   \   00000000   0029               CMP      R1,#+0
   \   00000002   818B               LDRH     R1,[R0, #+28]
   \   00000004   02D0               BEQ.N    ??I2S_Cmd_0
    368            {
    369              /* Enable the selected SPI peripheral (in I2S mode) */
    370              SPIx->I2SCFGR |= I2SCFGR_I2SE_Set;
   \   00000006   41F48061           ORR      R1,R1,#0x400
   \   0000000A   02E0               B.N      ??I2S_Cmd_1
    371            }
    372            else
    373            {
    374              /* Disable the selected SPI peripheral (in I2S mode) */
    375              SPIx->I2SCFGR &= I2SCFGR_I2SE_Reset;
   \                     ??I2S_Cmd_0:
   \   0000000C   4FF6FF32           MOVW     R2,#+64511
   \   00000010   1140               ANDS     R1,R2,R1
   \                     ??I2S_Cmd_1:
   \   00000012   8183               STRH     R1,[R0, #+28]
    376            }
    377          }
   \   00000014   7047               BX       LR               ;; return
    378          
    379          /*******************************************************************************
    380          * Function Name  : SPI_I2S_ITConfig
    381          * Description    : Enables or disables the specified SPI/I2S interrupts.
    382          * Input          : - SPIx: where x can be :
    383          *                         - 1, 2 or 3 in SPI mode 
    384          *                         - 2 or 3 in I2S mode
    385          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to be 
    386          *                    enabled or disabled. 
    387          *                    This parameter can be one of the following values:
    388          *                       - SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
    389          *                       - SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
    390          *                       - SPI_I2S_IT_ERR: Error interrupt mask
    391          *                  - NewState: new state of the specified SPI/I2S interrupt.
    392          *                    This parameter can be: ENABLE or DISABLE.
    393          * Output         : None
    394          * Return         : None
    395          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    396          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState)
    397          {
    398            u16 itpos = 0, itmask = 0 ;
    399          
    400            /* Check the parameters */
    401            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    402            assert_param(IS_FUNCTIONAL_STATE(NewState));
    403            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
    404          
    405            /* Get the SPI/I2S IT index */
    406            itpos = SPI_I2S_IT >> 4;
    407            /* Set the IT mask */
    408            itmask = (u16)((u16)1 << itpos);
   \                     SPI_I2S_ITConfig:
   \   00000000   0123               MOVS     R3,#+1
   \   00000002   0909               LSRS     R1,R1,#+4
   \   00000004   03FA01F1           LSL      R1,R3,R1
   \   00000008   89B2               UXTH     R1,R1
    409          
    410            if (NewState != DISABLE)
   \   0000000A   ....               B.N      ?Subroutine0
    411            {
    412              /* Enable the selected SPI/I2S interrupt */
    413              SPIx->CR2 |= itmask;
    414            }
    415            else
    416            {
    417              /* Disable the selected SPI/I2S interrupt */
    418              SPIx->CR2 &= (u16)~itmask;
    419            }
    420          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   002A               CMP      R2,#+0
   \   00000002   8288               LDRH     R2,[R0, #+4]
   \   00000004   01D0               BEQ.N    ??Subroutine0_0
   \   00000006   1143               ORRS     R1,R1,R2
   \   00000008   01E0               B.N      ??Subroutine0_1
   \                     ??Subroutine0_0:
   \   0000000A   C943               MVNS     R1,R1
   \   0000000C   1140               ANDS     R1,R1,R2
   \                     ??Subroutine0_1:
   \   0000000E   8180               STRH     R1,[R0, #+4]
   \   00000010   7047               BX       LR               ;; return
    421          
    422          /*******************************************************************************
    423          * Function Name  : SPI_I2S_DMACmd
    424          * Description    : Enables or disables the SPIx/I2Sx DMA interface.
    425          * Input          : - SPIx: where x can be :
    426          *                         - 1, 2 or 3 in SPI mode 
    427          *                         - 2 or 3 in I2S mode
    428          *                  - SPI_I2S_DMAReq: specifies the SPI/I2S DMA transfer request 
    429          *                    to be enabled or disabled. 
    430          *                    This parameter can be any combination of the following values:
    431          *                       - SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    432          *                       - SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    433          *                  - NewState: new state of the selected SPI/I2S DMA transfer 
    434          *                    request.
    435          *                    This parameter can be: ENABLE or DISABLE.
    436          * Output         : None
    437          * Return         : None
    438          *******************************************************************************/
    439          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState)
    440          {
    441            /* Check the parameters */
    442            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    443            assert_param(IS_FUNCTIONAL_STATE(NewState));
    444            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    445          
    446            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd:
   \   00000000                      REQUIRE ?Subroutine0
   \   00000000                      ;; // Fall through to label ?Subroutine0
    447            {
    448              /* Enable the selected SPI/I2S DMA requests */
    449              SPIx->CR2 |= SPI_I2S_DMAReq;
    450            }
    451            else
    452            {
    453              /* Disable the selected SPI/I2S DMA requests */
    454              SPIx->CR2 &= (u16)~SPI_I2S_DMAReq;
    455            }
    456          }
    457          
    458          /*******************************************************************************
    459          * Function Name  : SPI_I2S_SendData
    460          * Description    : Transmits a Data through the SPIx/I2Sx peripheral.
    461          * Input          : - SPIx: where x can be :
    462          *                         - 1, 2 or 3 in SPI mode 
    463          *                         - 2 or 3 in I2S mode
    464          *                  - Data : Data to be transmitted..
    465          * Output         : None
    466          * Return         : None
    467          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    468          void SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data)
    469          {
    470            /* Check the parameters */
    471            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    472            
    473            /* Write in the DR register the data to be sent */
    474            SPIx->DR = Data;
   \                     SPI_I2S_SendData:
   \   00000000   8181               STRH     R1,[R0, #+12]
    475          }
   \   00000002   7047               BX       LR               ;; return
    476          
    477          /*******************************************************************************
    478          * Function Name  : SPI_I2S_ReceiveData
    479          * Description    : Returns the most recent received data by the SPIx/I2Sx peripheral. 
    480          * Input          : - SPIx: where x can be :
    481          *                         - 1, 2 or 3 in SPI mode 
    482          *                         - 2 or 3 in I2S mode
    483          * Output         : None
    484          * Return         : The value of the received data.
    485          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    486          u16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    487          {
    488            /* Check the parameters */
    489            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    490            
    491            /* Return the data in the DR register */
    492            return SPIx->DR;
   \                     SPI_I2S_ReceiveData:
   \   00000000   8089               LDRH     R0,[R0, #+12]
   \   00000002   7047               BX       LR               ;; return
    493          }
    494          
    495          /*******************************************************************************
    496          * Function Name  : SPI_NSSInternalSoftwareConfig
    497          * Description    : Configures internally by software the NSS pin for the selected 
    498          *                  SPI.
    499          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    500          *                  - SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    501          *                    This parameter can be one of the following values:
    502          *                       - SPI_NSSInternalSoft_Set: Set NSS pin internally
    503          *                       - SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    504          * Output         : None
    505          * Return         : None
    506          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    507          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft)
    508          {
    509            /* Check the parameters */
    510            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    511            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    512          
    513            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig:
   \   00000000   4FF6FF62           MOVW     R2,#+65279
   \   00000004   9142               CMP      R1,R2
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   02D0               BEQ.N    ??SPI_NSSInternalSoftwareConfig_0
    514            {
    515              /* Set NSS pin internally by software */
    516              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
   \   0000000A   41F48071           ORR      R1,R1,#0x100
   \   0000000E   00E0               B.N      ??SPI_NSSInternalSoftwareConfig_1
    517            }
    518            else
    519            {
    520              /* Reset NSS pin internally by software */
    521              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \                     ??SPI_NSSInternalSoftwareConfig_0:
   \   00000010   1140               ANDS     R1,R2,R1
   \                     ??SPI_NSSInternalSoftwareConfig_1:
   \   00000012   0180               STRH     R1,[R0, #+0]
    522            }
    523          }
   \   00000014   7047               BX       LR               ;; return
    524          
    525          /*******************************************************************************
    526          * Function Name  : SPI_SSOutputCmd
    527          * Description    : Enables or disables the SS output for the selected SPI.
    528          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    529          *                  - NewState: new state of the SPIx SS output. 
    530          *                    This parameter can be: ENABLE or DISABLE.
    531          * Output         : None
    532          * Return         : None
    533          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    534          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    535          {
    536            /* Check the parameters */
    537            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    538            assert_param(IS_FUNCTIONAL_STATE(NewState));
    539          
    540            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd:
   \   00000000   0029               CMP      R1,#+0
   \   00000002   8188               LDRH     R1,[R0, #+4]
   \   00000004   02D0               BEQ.N    ??SPI_SSOutputCmd_0
    541            {
    542              /* Enable the selected SPI SS output */
    543              SPIx->CR2 |= CR2_SSOE_Set;
   \   00000006   41F00401           ORR      R1,R1,#0x4
   \   0000000A   02E0               B.N      ??SPI_SSOutputCmd_1
    544            }
    545            else
    546            {
    547              /* Disable the selected SPI SS output */
    548              SPIx->CR2 &= CR2_SSOE_Reset;
   \                     ??SPI_SSOutputCmd_0:
   \   0000000C   4FF6FB72           MOVW     R2,#+65531
   \   00000010   1140               ANDS     R1,R2,R1
   \                     ??SPI_SSOutputCmd_1:
   \   00000012   8180               STRH     R1,[R0, #+4]
    549            }
    550          }
   \   00000014   7047               BX       LR               ;; return
    551          
    552          /*******************************************************************************
    553          * Function Name  : SPI_DataSizeConfig
    554          * Description    : Configures the data size for the selected SPI.
    555          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    556          *                  - SPI_DataSize: specifies the SPI data size.
    557          *                    This parameter can be one of the following values:
    558          *                       - SPI_DataSize_16b: Set data frame format to 16bit
    559          *                       - SPI_DataSize_8b: Set data frame format to 8bit
    560          * Output         : None
    561          * Return         : None
    562          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    563          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize)
    564          {
    565            /* Check the parameters */
    566            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    567            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    568          
    569            /* Clear DFF bit */
    570            SPIx->CR1 &= (u16)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig:
   \   00000000   0288               LDRH     R2,[R0, #+0]
   \   00000002   4FF2FF73           MOVW     R3,#+63487
   \   00000006   1A40               ANDS     R2,R3,R2
   \   00000008   0280               STRH     R2,[R0, #+0]
    571            /* Set new DFF bit value */
    572            SPIx->CR1 |= SPI_DataSize;
   \   0000000A   0288               LDRH     R2,[R0, #+0]
   \   0000000C   1143               ORRS     R1,R1,R2
   \   0000000E   0180               STRH     R1,[R0, #+0]
    573          }
   \   00000010   7047               BX       LR               ;; return
    574          
    575          /*******************************************************************************
    576          * Function Name  : SPI_TransmitCRC
    577          * Description    : Transmit the SPIx CRC value.
    578          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    579          * Output         : None
    580          * Return         : None
    581          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    582          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    583          {
    584            /* Check the parameters */
    585            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    586            
    587            /* Enable the selected SPI CRC transmission */
    588            SPIx->CR1 |= CR1_CRCNext_Set;
   \                     SPI_TransmitCRC:
   \   00000000   0188               LDRH     R1,[R0, #+0]
   \   00000002   41F48051           ORR      R1,R1,#0x1000
   \   00000006   0180               STRH     R1,[R0, #+0]
    589          }
   \   00000008   7047               BX       LR               ;; return
    590          
    591          /*******************************************************************************
    592          * Function Name  : SPI_CalculateCRC
    593          * Description    : Enables or disables the CRC value calculation of the
    594          *                  transfered bytes.
    595          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    596          *                  - NewState: new state of the SPIx CRC value calculation.
    597          *                    This parameter can be: ENABLE or DISABLE.
    598          * Output         : None
    599          * Return         : None
    600          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    601          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    602          {
    603            /* Check the parameters */
    604            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    605            assert_param(IS_FUNCTIONAL_STATE(NewState));
    606          
    607            if (NewState != DISABLE)
   \                     SPI_CalculateCRC:
   \   00000000   0029               CMP      R1,#+0
   \   00000002   0188               LDRH     R1,[R0, #+0]
   \   00000004   02D0               BEQ.N    ??SPI_CalculateCRC_0
    608            {
    609              /* Enable the selected SPI CRC calculation */
    610              SPIx->CR1 |= CR1_CRCEN_Set;
   \   00000006   41F40051           ORR      R1,R1,#0x2000
   \   0000000A   02E0               B.N      ??SPI_CalculateCRC_1
    611            }
    612            else
    613            {
    614              /* Disable the selected SPI CRC calculation */
    615              SPIx->CR1 &= CR1_CRCEN_Reset;
   \                     ??SPI_CalculateCRC_0:
   \   0000000C   4DF6FF72           MOVW     R2,#+57343
   \   00000010   1140               ANDS     R1,R2,R1
   \                     ??SPI_CalculateCRC_1:
   \   00000012   0180               STRH     R1,[R0, #+0]
    616            }
    617          }
   \   00000014   7047               BX       LR               ;; return
    618          
    619          /*******************************************************************************
    620          * Function Name  : SPI_GetCRC
    621          * Description    : Returns the transmit or the receive CRC register value for
    622          *                  the specified SPI.
    623          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    624          *                  - SPI_CRC: specifies the CRC register to be read.
    625          *                    This parameter can be one of the following values:
    626          *                       - SPI_CRC_Tx: Selects Tx CRC register
    627          *                       - SPI_CRC_Rx: Selects Rx CRC register
    628          * Output         : None
    629          * Return         : The selected CRC register value..
    630          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    631          u16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC)
    632          {
    633            u16 crcreg = 0;
    634          
    635            /* Check the parameters */
    636            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    637            assert_param(IS_SPI_CRC(SPI_CRC));
    638          
    639            if (SPI_CRC != SPI_CRC_Rx)
   \                     SPI_GetCRC:
   \   00000000   0129               CMP      R1,#+1
   \   00000002   0CBF               ITE      EQ 
   \   00000004   808A               LDRHEQ   R0,[R0, #+20]
    640            {
    641              /* Get the Tx CRC register */
    642              crcreg = SPIx->TXCRCR;
   \   00000006   008B               LDRHNE   R0,[R0, #+24]
    643            }
    644            else
    645            {
    646              /* Get the Rx CRC register */
    647              crcreg = SPIx->RXCRCR;
    648            }
    649          
    650            /* Return the selected CRC register */
    651            return crcreg;
   \   00000008   7047               BX       LR               ;; return
    652          }
    653          
    654          /*******************************************************************************
    655          * Function Name  : SPI_GetCRCPolynomial
    656          * Description    : Returns the CRC Polynomial register value for the specified SPI.
    657          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    658          * Output         : None
    659          * Return         : The CRC Polynomial register value.
    660          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    661          u16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    662          {
    663            /* Check the parameters */
    664            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    665            
    666            /* Return the CRC polynomial register */
    667            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial:
   \   00000000   008A               LDRH     R0,[R0, #+16]
   \   00000002   7047               BX       LR               ;; return
    668          }
    669          
    670          /*******************************************************************************
    671          * Function Name  : SPI_BiDirectionalLineConfig
    672          * Description    : Selects the data transfer direction in bi-directional mode
    673          *                  for the specified SPI.
    674          * Input          : - SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    675          *                  - SPI_Direction: specifies the data transfer direction in
    676          *                    bi-directional mode. 
    677          *                    This parameter can be one of the following values:
    678          *                       - SPI_Direction_Tx: Selects Tx transmission direction
    679          *                       - SPI_Direction_Rx: Selects Rx receive direction
    680          * Output         : None
    681          * Return         : None
    682          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    683          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction)
    684          {
    685            /* Check the parameters */
    686            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    687            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    688          
    689            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig:
   \   00000000   4FF48042           MOV      R2,#+16384
   \   00000004   9142               CMP      R1,R2
   \   00000006   0188               LDRH     R1,[R0, #+0]
   \   00000008   02D1               BNE.N    ??SPI_BiDirectionalLineConfig_0
    690            {
    691              /* Set the Tx only mode */
    692              SPIx->CR1 |= SPI_Direction_Tx;
   \   0000000A   41F48041           ORR      R1,R1,#0x4000
   \   0000000E   02E0               B.N      ??SPI_BiDirectionalLineConfig_1
    693            }
    694            else
    695            {
    696              /* Set the Rx only mode */
    697              SPIx->CR1 &= SPI_Direction_Rx;
   \                     ??SPI_BiDirectionalLineConfig_0:
   \   00000010   4BF6FF72           MOVW     R2,#+49151
   \   00000014   1140               ANDS     R1,R2,R1
   \                     ??SPI_BiDirectionalLineConfig_1:
   \   00000016   0180               STRH     R1,[R0, #+0]
    698            }
    699          }
   \   00000018   7047               BX       LR               ;; return
    700          
    701          /*******************************************************************************
    702          * Function Name  : SPI_I2S_GetFlagStatus
    703          * Description    : Checks whether the specified SPI/I2S flag is set or not.
    704          * Input          : - SPIx: where x can be :
    705          *                         - 1, 2 or 3 in SPI mode 
    706          *                         - 2 or 3 in I2S mode
    707          *                  - SPI_I2S_FLAG: specifies the SPI/I2S flag to check. 
    708          *                    This parameter can be one of the following values:
    709          *                       - SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
    710          *                       - SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
    711          *                       - SPI_I2S_FLAG_BSY: Busy flag.
    712          *                       - SPI_I2S_FLAG_OVR: Overrun flag.
    713          *                       - SPI_FLAG_MODF: Mode Fault flag.
    714          *                       - SPI_FLAG_CRCERR: CRC Error flag.
    715          *                       - I2S_FLAG_UDR: Underrun Error flag.
    716          *                       - I2S_FLAG_CHSIDE: Channel Side flag.
    717          * Output         : None
    718          * Return         : The new state of SPI_I2S_FLAG (SET or RESET).
    719          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    720          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    721          {
    722            FlagStatus bitstatus = RESET;
    723          
    724            /* Check the parameters */
    725            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    726            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
    727          
    728            /* Check the status of the specified SPI/I2S flag */
    729            if ((SPIx->SR & SPI_I2S_FLAG) != (u16)RESET)
   \                     SPI_I2S_GetFlagStatus:
   \   00000000   0089               LDRH     R0,[R0, #+8]
   \   00000002   0140               ANDS     R1,R1,R0
   \   00000004   0800               MOVS     R0,R1
   \   00000006   18BF               IT       NE 
   \   00000008   0120               MOVNE    R0,#+1
    730            {
    731              /* SPI_I2S_FLAG is set */
    732              bitstatus = SET;
    733            }
    734            else
    735            {
    736              /* SPI_I2S_FLAG is reset */
    737              bitstatus = RESET;
    738            }
    739            /* Return the SPI_I2S_FLAG status */
    740            return  bitstatus;
   \   0000000A   40B2               SXTB     R0,R0
   \   0000000C   7047               BX       LR               ;; return
    741          }
    742          
    743          /*******************************************************************************
    744          * Function Name  : SPI_I2S_ClearFlag
    745          * Description    : Clears the SPIx CRC Error (CRCERR) flag.
    746          * Input          : - SPIx: where x can be :
    747          *                         - 1, 2 or 3 in SPI mode 
    748          *                  - SPI_I2S_FLAG: specifies the SPI flag to clear. 
    749          *                    This function clears only CRCERR flag.                                           
    750          *                  Notes:
    751          *                       - OVR (OverRun error) flag is cleared by software 
    752          *                         sequence: a read operation to SPI_DR register 
    753          *                         (SPI_I2S_ReceiveData()) followed by a read operation 
    754          *                         to SPI_SR register (SPI_I2S_GetFlagStatus()).                           
    755          *                       - UDR (UnderRun error) flag is cleared by a read 
    756          *                         operation to SPI_SR register (SPI_I2S_GetFlagStatus()).                             
    757          *                       - MODF (Mode Fault) flag is cleared by software sequence: 
    758          *                         a read/write operation to SPI_SR register 
    759          *                         (SPI_I2S_GetFlagStatus()) followed by a write 
    760          *                         operation to SPI_CR1 register (SPI_Cmd() to enable 
    761          *                         the SPI).   
    762          * Output         : None
    763          * Return         : None
    764          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    765          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG)
    766          {
    767            /* Check the parameters */
    768            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    769            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
    770              
    771              /* Clear the selected SPI CRC Error (CRCERR) flag */
    772              SPIx->SR = (u16)~SPI_I2S_FLAG;
   \                     SPI_I2S_ClearFlag:
   \   00000000   C943               MVNS     R1,R1
   \   00000002   0181               STRH     R1,[R0, #+8]
    773          }
   \   00000004   7047               BX       LR               ;; return
    774          
    775          /*******************************************************************************
    776          * Function Name  : SPI_I2S_GetITStatus
    777          * Description    : Checks whether the specified SPI/I2S interrupt has occurred or not.
    778          * Input          : - SPIx: where x can be :
    779          *                         - 1, 2 or 3 in SPI mode 
    780          *                         - 2 or 3 in I2S mode
    781          *                  - SPI_I2S_IT: specifies the SPI/I2S interrupt source to check. 
    782          *                    This parameter can be one of the following values:
    783          *                       - SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
    784          *                       - SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
    785          *                       - SPI_I2S_IT_OVR: Overrun interrupt.
    786          *                       - SPI_IT_MODF: Mode Fault interrupt.
    787          *                       - SPI_IT_CRCERR: CRC Error interrupt.
    788          *                       - I2S_IT_UDR: Underrun Error interrupt.
    789          * Output         : None
    790          * Return         : The new state of SPI_I2S_IT (SET or RESET).
    791          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    792          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    793          {
    794            ITStatus bitstatus = RESET;
    795            u16 itpos = 0, itmask = 0, enablestatus = 0;
    796          
    797            /* Check the parameters */
    798            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    799            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
    800          
    801            /* Get the SPI/I2S IT index */
    802            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
    803          
    804            /* Get the SPI/I2S IT mask */
    805            itmask = SPI_I2S_IT >> 4;
    806            /* Set the IT mask */
    807            itmask = (u16)((u16)0x01 << itmask);
    808            /* Get the SPI_I2S_IT enable bit status */
    809            enablestatus = (SPIx->CR2 & itmask) ;
   \                     SPI_I2S_GetITStatus:
   \   00000000   8288               LDRH     R2,[R0, #+4]
   \   00000002   0123               MOVS     R3,#+1
   \   00000004   4FEA111C           LSR      R12,R1,#+4
   \   00000008   03FA0CF3           LSL      R3,R3,R12
   \   0000000C   1A40               ANDS     R2,R3,R2
    810          
    811            /* Check the status of the specified SPI/I2S interrupt */
    812            if (((SPIx->SR & itpos) != (u16)RESET) && enablestatus)
   \   0000000E   0089               LDRH     R0,[R0, #+8]
   \   00000010   0123               MOVS     R3,#+1
   \   00000012   01F00F01           AND      R1,R1,#0xF
   \   00000016   03FA01F1           LSL      R1,R3,R1
   \   0000001A   0842               TST      R0,R1
   \   0000001C   03D0               BEQ.N    ??SPI_I2S_GetITStatus_0
   \   0000001E   1000               MOVS     R0,R2
   \   00000020   02D0               BEQ.N    ??SPI_I2S_GetITStatus_1
   \   00000022   0120               MOVS     R0,#+1
   \   00000024   00E0               B.N      ??SPI_I2S_GetITStatus_1
    813            {
    814              /* SPI_I2S_IT is set */
    815              bitstatus = SET;
    816            }
    817            else
    818            {
    819              /* SPI_I2S_IT is reset */
    820              bitstatus = RESET;
   \                     ??SPI_I2S_GetITStatus_0:
   \   00000026   0020               MOVS     R0,#+0
    821            }
    822            /* Return the SPI_I2S_IT status */
    823            return bitstatus;
   \                     ??SPI_I2S_GetITStatus_1:
   \   00000028   40B2               SXTB     R0,R0
   \   0000002A   7047               BX       LR               ;; return
    824          }
    825          
    826          /*******************************************************************************
    827          * Function Name  : SPI_I2S_ClearITPendingBit
    828          * Description    : Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
    829          * Input          : - SPIx: where x can be :
    830          *                         - 1, 2 or 3 in SPI mode 
    831          *                  - SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
    832          *                    This function clears only CRCERR intetrrupt pending bit.   
    833          *                  Notes:
    834          *                       - OVR (OverRun Error) interrupt pending bit is cleared 
    835          *                         by software sequence: a read operation to SPI_DR 
    836          *                         register (SPI_I2S_ReceiveData()) followed by a read 
    837          *                         operation to SPI_SR register (SPI_I2S_GetITStatus()).
    838          *                       - UDR (UnderRun Error) interrupt pending bit is cleared 
    839          *                         by a read operation to SPI_SR register 
    840          *                         (SPI_I2S_GetITStatus()).                           
    841          *                       - MODF (Mode Fault) interrupt pending bit is cleared by 
    842          *                         software sequence: a read/write operation to SPI_SR 
    843          *                         register (SPI_I2S_GetITStatus()) followed by a write 
    844          *                         operation to SPI_CR1 register (SPI_Cmd() to enable the 
    845          *                         SPI).   
    846          * Output         : None
    847          * Return         : None
    848          *******************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    849          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT)
    850          {
    851            u16 itpos = 0;
    852          
    853            /* Check the parameters */
    854            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    855            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
    856          
    857            /* Get the SPI IT index */
    858            itpos = (u16)((u16)0x01 << (SPI_I2S_IT & (u8)0x0F));
    859            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
    860            SPIx->SR = (u16)~itpos;
   \                     SPI_I2S_ClearITPendingBit:
   \   00000000   0122               MOVS     R2,#+1
   \   00000002   01F00F01           AND      R1,R1,#0xF
   \   00000006   02FA01F1           LSL      R1,R2,R1
   \   0000000A   89B2               UXTH     R1,R1
   \   0000000C   C943               MVNS     R1,R1
   \   0000000E   0181               STRH     R1,[R0, #+8]
    861          }
   \   00000010   7047               BX       LR               ;; return
    862          
    863          /******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                      .cstack
     --------                      -------
     I2S_Cmd                            0
     I2S_Init                           0
     I2S_StructInit                     0
     SPI_BiDirectionalLineConfig        0
     SPI_CalculateCRC                   0
     SPI_Cmd                            0
     SPI_DataSizeConfig                 0
     SPI_GetCRC                         0
     SPI_GetCRCPolynomial               0
     SPI_I2S_ClearFlag                  0
     SPI_I2S_ClearITPendingBit          0
     SPI_I2S_DMACmd                     0
     SPI_I2S_DeInit                     0
     SPI_I2S_GetFlagStatus              0
     SPI_I2S_GetITStatus                0
     SPI_I2S_ITConfig                   0
     SPI_I2S_ReceiveData                0
     SPI_I2S_SendData                   0
     SPI_Init                           0
     SPI_NSSInternalSoftwareConfig      0
     SPI_SSOutputCmd                    0
     SPI_StructInit                     0
     SPI_TransmitCRC                    0


   Section sizes:

     Function/Label                Bytes
     --------------                -----
     SPI_I2S_DeInit                  92
     SPI_Init                        56
     I2S_Init                       156
     SPI_StructInit                  24
     I2S_StructInit                  20
     SPI_Cmd                         22
     I2S_Cmd                         22
     SPI_I2S_ITConfig                12
     ?Subroutine0                    18
     SPI_I2S_DMACmd                   0
     SPI_I2S_SendData                 4
     SPI_I2S_ReceiveData              4
     SPI_NSSInternalSoftwareConfig   22
     SPI_SSOutputCmd                 22
     SPI_DataSizeConfig              18
     SPI_TransmitCRC                 10
     SPI_CalculateCRC                22
     SPI_GetCRC                      10
     SPI_GetCRCPolynomial             4
     SPI_BiDirectionalLineConfig     26
     SPI_I2S_GetFlagStatus           14
     SPI_I2S_ClearFlag                6
     SPI_I2S_GetITStatus             44
     SPI_I2S_ClearITPendingBit       18

 
 646 bytes in section .text
 
 646 bytes of CODE memory

Errors: none
Warnings: none
